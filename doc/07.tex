\documentclass{article}

\usepackage{amssymb, amsmath}
\usepackage{alltt}
\usepackage{pslatex}
\usepackage{epigraph}
\usepackage{verbatim}
\usepackage{latexsym}
\usepackage{array}
\usepackage{comment}
\usepackage{makeidx}
\usepackage{listings}
\usepackage{indentfirst}
\usepackage{verbatim}
\usepackage{color}
\usepackage{url}
\usepackage{xspace}
\usepackage{hyperref}
\usepackage{stmaryrd}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{graphicx}
\usepackage{euscript}
\usepackage{mathtools}
\usepackage{mathrsfs}
\usepackage{multirow,bigdelim}
\usepackage{subcaption}
\usepackage{placeins}

\makeatletter

\makeatother

\definecolor{shadecolor}{gray}{1.00}
\definecolor{darkgray}{gray}{0.30}

\def\transarrow{\xrightarrow}
\newcommand{\setarrow}[1]{\def\transarrow{#1}}

\def\padding{\phantom{X}}
\newcommand{\setpadding}[1]{\def\padding{#1}}

\def\subarrow{}
\newcommand{\setsubarrow}[1]{\def\subarrow{#1}}

\newcommand{\trule}[2]{\frac{#1}{#2}}
\newcommand{\crule}[3]{\frac{#1}{#2},\;{#3}}
\newcommand{\withenv}[2]{{#1}\vdash{#2}}
\newcommand{\trans}[3]{{#1}\transarrow{\padding{\textstyle #2}\padding}\subarrow{#3}}
\newcommand{\ctrans}[4]{{#1}\transarrow{\padding#2\padding}\subarrow{#3},\;{#4}}
\newcommand{\llang}[1]{\mbox{\lstinline[mathescape]|#1|}}
\newcommand{\pair}[2]{\inbr{{#1}\mid{#2}}}
\newcommand{\inbr}[1]{\left<{#1}\right>}
\newcommand{\highlight}[1]{\color{red}{#1}}
\newcommand{\ruleno}[1]{\eqno[\scriptsize\textsc{#1}]}
\newcommand{\rulename}[1]{\textsc{#1}}
\newcommand{\inmath}[1]{\mbox{$#1$}}
\newcommand{\lfp}[1]{fix_{#1}}
\newcommand{\gfp}[1]{Fix_{#1}}
\newcommand{\vsep}{\vspace{-2mm}}
\newcommand{\supp}[1]{\scriptsize{#1}}
\newcommand{\sembr}[1]{\llbracket{#1}\rrbracket}
\newcommand{\cd}[1]{\texttt{#1}}
\newcommand{\free}[1]{\boxed{#1}}
\newcommand{\binds}{\;\mapsto\;}
\newcommand{\dbi}[1]{\mbox{\bf{#1}}}
\newcommand{\sv}[1]{\mbox{\textbf{#1}}}
\newcommand{\bnd}[2]{{#1}\mkern-9mu\binds\mkern-9mu{#2}}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newcommand{\meta}[1]{{\mathcal{#1}}}
\renewcommand{\emptyset}{\varnothing}
\newcommand{\dom}[1]{\mathtt{dom}\;{#1}}
\newcommand{\primi}[2]{\mathbf{#1}\;{#2}}

\definecolor{light-gray}{gray}{0.90}
\newcommand{\graybox}[1]{\colorbox{light-gray}{#1}}

\lstdefinelanguage{ocaml}{
keywords={let, begin, end, in, match, type, and, fun, 
function, try, mod, with, class, object, method, of, rec, repeat, until,
while, not, do, done, as, val, inherit, module, sig, @type, struct, 
if, then, else, open, virtual, new, fresh, skip, od, fi, elif, for, local, return, read, write, fi, case, esac, od},
sensitive=true,
%basicstyle=\small,
commentstyle=\scriptsize\rmfamily,
keywordstyle=\ttfamily\bfseries,
identifierstyle=\ttfamily,
basewidth={0.5em,0.5em},
columns=fixed,
fontadjust=true,
literate={->}{{$\to$}}3 {===}{{$\equiv$}}1 {=/=}{{$\not\equiv$}}1 {|>}{{$\triangleright$}}3 {\&\&\&}{{$\wedge$}}2 {|||}{{$\vee$}}2 {^}{{$\uparrow$}}1,
morecomment=[s]{(*}{*)}
}

\lstset{
mathescape=true,
%basicstyle=\small,
identifierstyle=\ttfamily,
keywordstyle=\bfseries,
commentstyle=\scriptsize\rmfamily,
basewidth={0.5em,0.5em},
fontadjust=true,
escapechar=!,
language=ocaml
}

\sloppy

\newcommand{\ocaml}{\texttt{OCaml}\xspace}

\theoremstyle{definition}

\title{Arrays and strings}

\author{Dmitry Boulytchev}

\begin{document}

\maketitle

An array can be represented as a pair: the length of the array and a mapping from indices to elements. If we denote
$\mathscr E$ the set of elements then the set of all arrays $\mathscr A (\mathscr E)$ can be defined as follows:

\[
\mathscr A(\mathscr E) = \mathbb N \times (\mathbb N \to \mathscr E)
\]

For an array $(n, f)$ we assume $\dom{f}=[0\,..\,n-1]$. An element selection function:

\[
\begin{array}{c}
  \bullet[\bullet] : \mathscr A (\mathscr E) \to \mathbb N \to \mathscr E\\[2mm]
  (n, f) [i] = \left\{
                  \begin{array}{rcl}
                     f\;i &, & i < n\\
                     \bot&,&\;\mbox{otherwise}
                  \end{array}
               \right.
\end{array}
\]

We represent arrays by \emph{references}. Thus, we introduce a (linearly) ordered set of locations

\[
\mathscr L = \{l_0, l_1, \dots\}
\]

Now, the set of all values the programs operate on can be described as follows:

\[
    \mathscr V = \mathbb Z \uplus \mathscr L 
\]

Here, every value is either an integer, or a reference (some location). The disjoint union ``$\uplus$'' makes it possible to
unambiguously discriminate between the shapes of each value. To access arrays, we introduce an abstraction of memory:


\[
    \mathscr M = \mathscr L \to \mathscr A\,(\mathscr V)
\]

We now add two more components to the configurations: a memory function $\mu$ and the first free memory location $l_m$, and
define the following primitive:

\[
\primi{mem}{\inbr{s,\,\mu,\,l_m,\,i,\,o,\,v}}=\mu
\]

which gives a memory function from a configuration.

\subsection{Adding arrays on expression level}

On expression level, abstractly/concretely:

\[
\begin{array}{rclll}
\mathscr E += &      &\mathscr E \mathtt{[} \mathscr E \mathtt{]} & (\llang{$a$ [$e$]})               & \mbox{taking an element}\\
              & \mid & \mathtt{[} \mathscr E^* \mathtt{]}         & (\llang{[$e_1$, $e_2$,.., $e_k$]}) & \mbox{creating an array}\\
              & \mid & \mathscr E \mathtt{.length}                & ($e$\mathtt{.length})             & \mbox{taking the length}
\end{array}
\]

%In addition, in a concrete syntax we supply two special forms for strings: \llang{'$x$'} as a denotation for integer code of ASCII symbol
%$x$, and \llang{"..."}~--- a string constant.

The semantics of enriched expressions is modified as follows. First, we add two additional premises to the rule for binary operators:

\setsubarrow{_{\mathscr E}}
\arraycolsep=10pt
\[\trule{\begin{array}{cc}
            \withenv{\Phi}{\trans{c}{A}{c^\prime}} & \withenv{\Phi}{\trans{c^\prime}{B}{c^{\prime\prime}}}\\
            \primi{val}{c^\prime}\in\mathbb Z      & \primi{val}{c^{\prime\prime}}\in\mathbb Z
          \end{array}
        }
        {\withenv{\Phi}{\trans{c}{A\otimes B}{\primi{ret}{c^{\prime\prime}\;(\primi{val}{c^\prime}\oplus \primi{val}{c^{\prime\prime}})}}}}
        \ruleno{Binop}
\]
       
These two premises ensure that both operand expressions are evaluated into integer values. Second, we have to add the rules for new
kinds of expressions (see Figure~\ref{array_expressions}).

\begin{figure}
  \arraycolsep=10pt  
  \[\trule{\begin{array}{cc}
             \withenv{\Phi}{\trans{c}{e}{c^\prime}} &\withenv{\Phi}{\trans{c^\prime}{j}{c^{\prime\prime}}}\\
             l=\primi{val}{c^\prime}                &j=\primi{val}{c^{\prime\prime}}\\
             l\in\mathscr L                       &j\in\mathbb N\\
             (n,\,f)=\primi{mem}{l}               &j<n
           \end{array}}
          {\withenv{\Phi}{\trans{c}{e\,\mathtt{[}j\mathtt{]}}{\primi{ret}{c^{\prime\prime}(f\;j)}}}}
          \ruleno{ArrayElement}
  \]
  \vskip5mm        
  \[\trule{\begin{array}{c}
              \withenv{\Phi}{\trans{c_j}{e_j}{c_{j+1}}},\,j\in [0..k]\\
              \inbr{s,\,\mu,\,l_m,\,i,\,o,\,\_}=c_{k+1}
           \end{array}
          }
          {\withenv{\Phi}{\trans{c_0}{\mathtt{[}e_0, e_1,...,e_k\mathtt{]}}{\inbr{s,\,\mu\,[l_m\gets(k+1,\,\lambda n.\primi{val}{c_n})],\,l_{m+1},\,i,\,o,\,l_m}}}}
          \ruleno{Array}
  \]
  \vskip5mm        
  \[\trule{\begin{array}{c}
              \withenv{\Phi}{\trans{c}{e}{c^\prime}}\\
              l=\primi{val}{c^\prime}\\
              l\in\mathscr L\\
              (n,\,f)=(\primi{mem}{c^\prime})\;l
            \end{array}
          }
          {\withenv{\Phi}{\trans{c}{e\mathtt{.length}}{\primi{return}{c^\prime\;n}}}}
          \ruleno{ArrayLength}
  \]
  \caption{Big-step Operational Semantics for Array Expressions}
  \label{array_expressions}
\end{figure}

\subsection{Adding arrays on statement level}

On statement level, we add the single construct:

\[
\mathscr S += \mathscr E \mathtt{[} \mathscr E \mathtt{]} \llang{:=} \mathscr E
\]

This construct is interpreted as an assignment to an element of an array. The semantics of this construct is described by the following rule:
\[
\trule{\setsubarrow{_{\mathscr E}}
       \arraycolsep=10pt    
       \begin{array}{ccc}
         \withenv{\Phi}{\trans{c}{e}{c^\prime}} & \withenv{\Phi}{\trans{c^\prime}{j}{c^{\prime\prime}}} & \withenv{\Phi}{\trans{c^{\prime\prime}}{g}{\inbr{s,\mu,l_m,i,o,v}}}\\
            l=\primi{val}{c^\prime}             & i=\primi{val}{c^{\prime\prime}}                     & \\
            l\in\mathscr L                     &  i\in\mathbb N                                   & \\[3mm]
            \multicolumn{3}{c}{(n,\,f)=\mu\;l}\\
            \multicolumn{3}{c}{i<n}\\
            \multicolumn{3}{c}{\setsubarrow{}\withenv{\llang{skip},\,\Phi}{\trans{\inbr{s,\,\mu\,[l\gets (n,\,f\,[i\gets x])],\,l_m,\,i,\,o,\,\hbox{---}}}{K}{\widetilde{c}}}}
       \end{array}
      }
      {\setsubarrow{}\withenv{K,\,\Phi}{\trans{c}{e\mathtt{[}j\mathtt{]}\llang{:=}g}{\widetilde{c}}}}
      \ruleno{ArrayAssign}
\]

\subsection{Strings}

With arrays in our hands, we can easily add strings as arrays of characters. In fact, on the source language the strings can be
introduced as a syntactic extension:

\begin{enumerate}
  \item we add a character constants \llang{'c'} as a shortcut for their integer codes;
  \item we add a string literals \llang{"abcd..."} as a shortcut for arrays \llang{['a', 'b', 'c', 'd', ...]}.
\end{enumerate}

Nothing else has to be done~--- now we have mutable reference-representable strings.

\end{document}